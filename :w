use chrono::{serde::ts_microseconds, DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::borrow::Cow;
use std::error;
use textwrap::Options;

pub const DEFAULT_TEXT_WIDTH_PERCENT: u16 = 60;
pub const FULL_TEXT_WIDTH_PERCENT: u16 = 96;
const STARTING_SAMPLE_SIZE: usize = 100;

pub type AppResult<T> = std::result::Result<T, Box<dyn error::Error>>;

pub struct App<PA: PlatformAdapter> {
    pub running: bool,
    pub adapter: PA,
    pub settings: Settings,
}

pub struct OpenText<'a> {
    text: &'a str,
    pub test: Test,
    pub focused_char: usize,
    pub wrapper: TextWrapper<'a>,
    test_log: Vec<TestResult>,
    keypress_log: Vec<KeyPress>,
    save: Box<dyn Fn(Vec<TestResult>, Vec<KeyPress>)>,
}

pub struct Test {
    pub start_index: usize,
    pub length: usize,
    pub cur_char: usize,
    start_time: DateTime<Utc>,
}

pub struct TextWrapper<'a> {
    text: &'a str,
    cur_width: u16,
    lines: Vec<usize, &'a str>,
}

pub struct Settings {
    pub text_width_percent: u16,
    pub full_text_width: bool,
}

impl<'a> TextWrapper<'a> {
    fn new(text: &'a str) -> Self {
        Self {
            text,
            cur_width: 0,
            lines: Vec::new(),
            line_starts: Vec::new(),
        }
    }

    fn wrap(&mut self, line_width: u16) {
        if line_width == self.cur_width {
            return;
        };
        self.cur_width = line_width;

        let options: Options = Options::new(self.cur_width as usize)
            .break_words(false)
            .word_splitter(textwrap::WordSplitter::NoHyphenation)
            .preserve_trailing_space(true);
        let wrapped_lines: Vec<Cow<'a, str>> = textwrap::wrap(self.text, &options);

        self.lines = Vec::new();
        self.line_starts = Vec::new();
        let mut prefix_sum: usize = 0;
        for cow in wrapped_lines {
            let line = match cow {
                Cow::Borrowed(s) => s,
                Cow::Owned(_) => panic! {"Jesse has misunderstood the textwrap library."},
            };
            self.lines.push(line);
            self.line_starts.push(prefix_sum);
            prefix_sum += line.len();
        }
    }

    pub fn lines(&mut self, line_width: u16) -> &Vec<&'a str> {
        self.wrap(line_width);
        &self.lines
    }

    pub fn line_starts(&mut self, line_width: u16) -> &Vec<usize> {
        self.wrap(line_width);
        &self.line_starts
    }

    pub fn line_of_idx(&mut self, idx: usize, line_width: u16) -> usize {
        self.wrap(line_width);
        match self.line_starts.binary_search(&idx) {
            Ok(l) => l,
            Err(l) => l - 1,
        }
    }
}

impl Settings {
    pub fn new() -> Self {
        Self {
            text_width_percent: DEFAULT_TEXT_WIDTH_PERCENT,
            full_text_width: false,
        }
    }

    pub fn line_width(&self, terminal_width: u16) -> u16 {
        ((terminal_width as usize) * (self.text_width_percent as usize) / 100) as u16
    }
}

impl Default for Settings {
    fn default() -> Self {
        Self::new()
    }
}

pub trait PlatformAdapter {
    fn get_texts(&self) -> Vec<TextHandle<'_>>;
}

pub struct TextHandle<'a> {
    pub name: &'a str,
    pub length: usize,
    pub last_opened: DateTime<Utc>,
    open: Box<dyn FnOnce()>,
}

impl<'a> Drop for OpenText<'a> {
    fn drop(&mut self) {
        (self.save)(self.test_log.clone(), self.keypress_log.clone());
    }
}

impl Test {
    fn next(text: &str, test_log: &Vec<TestResult>) -> Test {
        let mut start_index = 0;
        for t in test_log {
            if t.succeeded && t.end_index > start_index {
                start_index = t.end_index;
            }
        }

        let avg_50 = test_log
            .iter()
            .map(|t| t.end_index - t.start_index)
            .filter(|&len| len > 5)
            .rev()
            .take(50)
            .sum::<usize>()
            / 50;
        let max_10 = test_log
            .iter()
            .map(|t| t.end_index - t.start_index)
            .filter(|&len| len > 5)
            .rev()
            .take(10)
            .max()
            .unwrap_or(STARTING_SAMPLE_SIZE);
        let best = usize::max(avg_50, max_10) + 5;

        let wrong_num = test_log
            .iter()
            .rev()
            .take_while(|t| !t.succeeded)
            .map(|t| t.end_index - t.start_index)
            .filter(|&len| len > 5)
            .count();

        let full = text
            .chars()
            .skip(start_index)
            .take(best)
            .collect::<String>();

        let len = full
            .split_whitespace()
            .rev()
            .skip(usize::max(wrong_num, 1))
            .collect::<Vec<_>>()
            .join(" ")
            .len()
            + 1;

        Test {
            start_index: usize::min(start_index, text.len() - 1),
            cur_char: 0,
            length: usize::min(len, text.len() - start_index - 1),
            start_time: Utc::now(),
        }
    }
}

impl<'a> OpenText<'a> {
    pub fn new<Save, Delete>(text: &'a str, sample_log: Vec<TestResult>, save: Save) -> Self
    where
        Save: Fn(Vec<TestResult>, Vec<KeyPress>) -> () + 'static,
        Delete: Fn() -> () + 'static,
    {
        let test = Test::next(text, &sample_log);
        Self {
            text,
            focused_char: test.start_index,
            test,
            wrapper: TextWrapper::new(text),
            test_log: sample_log,
            save: Box::new(save),
            keypress_log: Default::default(),
        }
    }

    pub fn snap_to_cursor(&mut self) {
        self.focused_char = self.test.start_index + self.test.cur_char;
    }

    pub fn get_rolling_average(&self) -> usize {
        self.test_log
            .iter()
            .map(|t| t.end_index - t.start_index)
            .filter(|&len| len > 5)
            .rev()
            .take(10)
            .sum::<usize>()
            / 10
    }

    pub fn handle_char(&mut self, c: char) {
        let correct = c
            == self
                .text
                .chars()
                .nth(self.test.start_index + self.test.cur_char)
                .unwrap();

        if correct {
            if self.test.cur_char == 0 {
                self.test.start_time = Utc::now();
            }
            self.test.cur_char += 1
        }
        if !correct || self.test.cur_char == self.test.length {
            self.test_log.push(TestResult {
                succeeded: correct,
                start_index: self.test.start_index,
                end_index: self.test.start_index + self.test.cur_char,
                started: self.test.start_time,
                completed: Utc::now(),
            });
            self.test = Test::next(self.text, &self.test_log);
        }

        let log_entry = &KeyPress {
            correct,
            key: c,
            time: Utc::now(),
        };
        self.keypress_log.push(log_entry.clone());
        self.snap_to_cursor();
    }
}

impl<PA: PlatformAdapter> App<PA> {
    pub fn new(adapter: PA) -> Self {
        Self {
            adapter,
            settings: Settings::default(),
            running: true,
        }
    }

    pub fn quit(&mut self) {
        self.running = false;
    }
}

#[derive(Serialize, Deserialize, Clone)]
pub struct KeyPress {
    correct: bool,
    key: char,
    #[serde(with = "ts_microseconds")]
    time: DateTime<Utc>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct TestResult {
    succeeded: bool,
    start_index: usize,
    end_index: usize,
    #[serde(with = "ts_microseconds")]
    started: DateTime<Utc>,
    #[serde(with = "ts_microseconds")]
    completed: DateTime<Utc>,
}
